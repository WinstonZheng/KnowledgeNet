# UDP
## 面向无连接
类比于TCP的三次握手连接，UDP只需要将数据封装成UDP数据报，然后封装成IP数据报的方式进行传输。（那么，如果数据报过长，怎么办？UDP依赖于IP层提供的数据分片支持，将数据进行切片封装）

## UDP数据分片
UDP本身并不做分组，UDP数据报容易产生IP分组（IP数据包），分组依据依靠于不同两路的MTU，每个IP分组头部都相同，除了偏移量和标志位，而且UDP首部只在第一个数据分组中。这种分片方式是在传输过程的路由器中执行，对主机起始端不可见（由于IP数据分组，只要有一个分组错误，就重传整个IP数据包，而TCP数据分段可以只传中间错误的段，所以TCP尽量避免IP分片）。

> IP在分片前是数据报，在分片后则叫分组（实际传输的数据单元）。

## 差错检验
UDP的校验和是可选的，通过校验和可以判断数据包是否出现差错。（如果关闭，可以依赖于链路层校验，而由于路由器也会发生差错，这种问题不会被检查出来）而当UCP数据包产生差错时，就直接被丢弃了，IP层检测到错误之后，也会做这样的处理。

> 从这一点来看，可以看出UDP是不可靠的。

## 拥塞控制
UDP是不存在拥塞控制的，当Linux缓冲队列满时，抛弃数据报（可能不产生ICMP差错，因为可能丢失的是第一个IP分组，丢失源主机的地址和端口号）。UDP只是尽最大努力交付（不可靠），吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、源端和终端主机性能的限制。
> 第一次UDP传输之前，会发送ARP指令，如果因为IP分片，造成多个IP请求，会导致多个ARP指令。

## 总结
UDP不可靠的传输，一般是通过应用层（或者Socket底层实现）控制超时重传（定时器）机制。支持一对一、一对多、多对一和多对多的交互通信。

# TCP
## 连接建立与终止
- 三次握手的主要原因：
    - 防止过期的连接请求再次传递到服务端，当客户端连接服务端的请求SYN，由于网络原因导致滞留后，发送给服务端，而其实客户端因为超时重发机制，早已经重发SYN，但是此时服务端会认为这是客户端新连接的请求，则会发送SYN + ACK。如果是二次连接，当客户端接收到，认为无效请求，不予理睬；服务端则认为已经建立请求，开始发送数据。
   
- 四次挥手的主要原因：主动关闭的一方，等待被关闭的另一方发送剩余数据。

- TIME_WAIT时间原因：
    - 确保最后一个确认报文段能够到达。如果 B 没收到 A 发送来的确认报文段，那么就会重新发送连接释放请求报文段，A 等待一段时间就是为了处理这种情况的发生。
    - 等待一段时间是为了让本连接持续时间内所产生的所有报文段都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文段。

> TIME_WAIT状态也称为2MSL等待状态，每个具体TCP实现，必须选择一个报文段中最大生成时间MSL（指报文在丢弃前在网络内最长的时间），这个时间内，可能存在一个未到达的报文，都被丢弃。

## 分段
TCP依赖于MSS进行分段，

## 差错检验
TCP采用滑动窗口协议进行流量控制。


## 拥塞控制



# 两者比较
- 数据发生错误？ UDP直接根据可选的校验和进行判断（没有，则通过其他层数据校验）



> 网络传输的次序，是big endian字节序。