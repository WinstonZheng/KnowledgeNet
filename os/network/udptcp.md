# UDP
## 面向无连接
类比于TCP的三次握手连接，UDP只需要将数据封装成UDP数据报，然后封装成IP数据报的方式进行传输。（那么，如果数据报过长，怎么办？UDP依赖于IP层提供的数据分片支持，将数据进行切片封装）

## UDP数据分片
UDP本身并不做分组，UDP数据报容易产生IP分组（IP数据包），每个IP分组头部都相同，除了偏移量和标志位，而且UDP首部只在第一个数据分组中。这种分片方式是在传输过程的路由器中执行，对主机起始端不可见（由于IP数据分组，只要有一个分组错误，就重传整个IP数据包，而TCP数据分段可以只传中间错误的段，所以TCP尽量避免IP分片）。

> IP在分片前是数据报，在分片后则叫分组（实际传输的数据单元）。

## 差错检验
UDP的校验和是可选的，通过校验和可以判断数据包是否出现差错。（如果关闭，可以依赖于链路层校验，而由于路由器也会发生差错，这种问题不会被检查出来）而当UCP数据包产生差错时，就直接被丢弃了，IP层检测到错误之后，也会做这样的处理。

> 从这一点来看，可以看出UDP是不可靠的。

## 拥塞控制
UDP是不存在拥塞控制的，当Linux缓冲队列满时，抛弃数据报（可能不产生ICMP差错，因为可能丢失的是第一个IP分组，丢失源主机的地址和端口号）。UDP只是尽最大努力交付（不可靠），吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、源端和终端主机性能的限制。
> 第一次UDP传输之前，会发送ARP指令，如果因为IP分片，造成多个IP请求，会导致多个ARP指令。

## 总结
UDP不可靠的传输，一般是通过应用层（或者Socket底层实现）控制超时重传（定时器）机制。支持一对一、一对多、多对一和多对多的交互通信。

# TCP
## 连接建立与终止


## 分段

## 差错检验

## 拥塞控制



# 两者比较


- 数据发生错误？ UDP直接根据可选的校验和进行判断（没有，则通过其他层数据校验）



> 网络传输的次序，是big endian字节序。