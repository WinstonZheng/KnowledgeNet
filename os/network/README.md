# IO模型
IO操作主要分为两个阶段：
1. 等待数据到达（数据传输到窗口缓冲区）；
2. 从内核缓冲区将数据复制到用户进程缓冲区内；

> 阻塞非阻塞指的是等待数据到达时程序执行的状态；同步与异步，指的是数据读取是用户进程主动进行阻塞读取操作，还是内核操作完成后通知用户进程。

IO模型的分类：
1. 阻塞式IO;
2. 非阻塞式IO；
3. I/O复用（select和poll）；
4. 信号驱动式I/O（SIG IO）；
5. 异步I/O（AIO）；

## 阻塞式IO
应用进程阻塞式等待，直到将数据复制到应用进程缓冲区后返回（阻塞不消耗CPU时间，recvfrom）。

![](/assets/blockedio.png)

## 非阻塞式IO
应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling）。（由于反复执行系统调用，较为低效）

![](/assets/nonblockedio.png)

## IO复用
使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读，这一过程会被阻塞，当某一个套接字可读时返回。之后再使用 recvfrom 把数据从内核复制到进程中。能让单个进程处理多个IO事件，又称为事件驱动IO。

![](/assets/multiplexingio.png)

## 信号驱动IO
应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。

![](/assets/sigactionio.png)

## 异步IO
进行 aio_read 系统调用会立即返回，应用进程继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。

![](/assets/asynio.png)


## 比较
![](/assets/iomodelcompare.png)






# Reference
- TCP/IP详解卷一：协议
- Linux高性能服务器编程