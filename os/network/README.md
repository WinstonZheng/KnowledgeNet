# IO模型
IO操作主要分为两个阶段：
1. 等待数据到达（数据传输到窗口缓冲区）；
2. 从内核缓冲区将数据复制到用户进程缓冲区内；

> 阻塞非阻塞指的是等待数据到达时程序执行的状态；同步与异步，指的是数据读取是用户进程主动进行阻塞读取操作，还是内核操作完成后通知用户进程。

IO模型的分类：
1. 阻塞式IO;
2. 非阻塞式IO；
3. I/O复用（select和poll）；
4. 信号驱动式I/O（SIG IO）；
5. 异步I/O（AIO）；

## 阻塞式IO
应用进程阻塞式等待，直到将数据复制到应用进程缓冲区后返回（阻塞不消耗CPU时间，recvfrom）。

![](/assets/blockedio.png)

## 非阻塞式IO
应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling）。（由于反复执行系统调用，较为低效）

![](/assets/nonblockedio.png)

## IO复用
使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读，这一过程会被阻塞，当某一个套接字可读时返回。之后再使用 recvfrom 把数据从内核复制到进程中。能让单个进程处理多个IO事件，又称为事件驱动IO。

![](/assets/multiplexingio.png)

## 信号驱动IO
应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。

![](/assets/sigactionio.png)

## 异步IO
进行 aio_read 系统调用会立即返回，应用进程继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。

![](/assets/asynio.png)


## 比较
![](/assets/iomodelcompare.png)


# Socket
select、poll和epoll都是IO复用的实现方式。

## 维护描述符
- select，是将描述符放在数组中（FD_SETSIZE），修改需要重新编译，用户进程；
- poll，是将描述符放到链表中，所以没有大小限制，用户进程；
- epoll，是将描述符放置在红黑树中，内核进程；

> 所以，select和poll调用，每次都会将描述符从用户缓冲区复制到内核缓冲区。

## 如何获取就绪的文件描述符
- 当数据就绪时（返回 > 0），select和poll操作，应用程序通过轮询的方式找到IO完成描述符；
- 当IO准备就绪时，epoll通过回调函数将就绪的文件描述符加入到链表中；

## 多线程操作
- 如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。
- epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。

## 适用场景
- select适用场景，select 的 timeout 参数精度为 1ns，而 poll 和 epoll 为 1ms，因此 select 更加适用于实时要求更高的场景，比如核反应堆的控制。select 可移植性更好，几乎被所有主流平台所支持。

- poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。需要同时监控**小于 1000 个描述符**，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。需要监控的**描述符状态变化多，而且都是非常短暂的**，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且epoll 的描述符存储在内核，不容易调试。

- epoll，只需要运行在 Linux 平台上，并且有非常大量的描述符需要同时轮询，而且这些连接最好是长连接。

> epoll支持LT（level trigger）模式和ET（edge trigger）模式：
    - 当epoll_wait()检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait()会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。
    - 和 LT 模式不同的是，通知之后进程必须**立即处理事件**，下次再调用 epoll_wait() 时不会再得到事件到达的通知。很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。

# Reference
- TCP/IP详解卷一：协议
- Linux高性能服务器编程
- [Socket](https://github.com/CyC2018/Interview-Notebook/blob/master/notes/Socket.md)