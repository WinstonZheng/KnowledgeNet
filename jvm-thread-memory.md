# 内存模型

## 特征


## 先行发生原则
判断数据是否存在竞争、线程是否安全的主要依据。
- 程序次序规则(Program Order Rule）：在一个线程内，按照程序代码顺序，写在前面的操作先行发生于写在后面的操作（控制流顺序，考虑分支、循环）。
- 管程锁定原则（Monitor Lock Rule）：一个unlock操作先行发生于后面对同一个锁的lock操作；（包括时间先后）
- volatile变量规则（Volatile Variable Rule）：对于一个volatile变量写操作先行发生于后面对这个变量的读操作；（包括时间先后）
- 线程启动规则（Thread Start Rule）：Thread的start()操作先行发生于此线程中每个操作；
- 线程终止规则（Thread Termination Rule）：线程中所有操作都先行发生于对此线程的终止检测（通过Thread.join()、Thread.isAlive()检测线程终止）；
- 线程中断规则（Thread Interruption Rulle）:对线程的interrupt()方法调用先行发生于被中断线程的代码检测到中断事件的发生；
- 对象终结规则（Thread Interruption Rule）：一个对象初始化完成（构造函数执行结束），先行发生于它的finalize()方法开始；
- 传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那么操作A先行发生于操作C。

> 注意：时间顺序和先行顺序无太大关系，典型案例，在一个线程中的两个变量赋值，顺序可能多变。


## volatile
使用场景
1. 运算结果并不依赖与当前值；
2. 确保只有一条线程在修改值；
3. 变量不需要与其他变量共同参与不变约束。 

volatile修饰的关键字由如下两种特性。

### 保证此变量对所有线程的可见性
  在考虑实现之前，volatile修饰的变量并不是严格的线程安全的，当由多个线程修改该变量，同样能导致不一致的情况出现。首先，理解线程不安全，由于每个线程由单独的工作内存，工作内存修改的变量不会实时与主内存同步，所以多线程操作可能存在不一致的情况。
  
- 如何实现？
  volatile保证了线程工作内存中的该变量在使用前，需要先从主内存加载；而修改后，立即写回到主内存中。但是，尽管如此，也不能保证多线程修改的安全性。
  
### 禁止指令重排序
#### 概念
- 指令重排
  从硬件的架构角度理解，指令重排序是指CPU采用允许多条指令不按照程序规定的顺序分开发给各个相应电路单元处理，此外，重排的指令应该是互相没有依赖关系（CPU控制指令依赖）。
  
- 内存屏障（Memory Barrier or Memory Fence）
  指重排序时，不能把后面的指令重排序到内存屏障之前的位置。实现的思路，考虑指令重排的概念，CPU通过lock指令设置屏障，当CPU运行到lock指令，会将CPU内的修改全部同步到内存中，所以造成了屏障效果。

- 如何实现？
  volatile修饰的变量在使用或者修改时，造成了内存屏障的效果。
    
> volatile的开销比锁低

### 规则描述
volatile修饰变量遵循以下原则：
1. use与load需要按顺序连续一起出现（每次使用前从主内存刷新值）；
2. assign与store需要连续一起出现（修改后，必须同步回内存）；
3. 禁止指令优化，保证代码顺序与程序顺序相同。





