# 类加载
## 类文件
构成了java虚拟机语言无关性的基石，java字节码的语义描述能力高于java语言语义描述能力。

## 概述
虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可被虚拟机直接使用的JAVA类型。
> 注意：类加载、连接和初始化都是在运行期（面向接口编程，在运行时指定实现类），这种特性给Java程
序提供灵活性。

## 流程（简）
- 加载（Loading）
- 连接（Linking）
 - 验证（Verification）
 - 准备（Preparation）
 - 解析（Resolution）
- 初始化（Initialization）
- 使用（Using）
- 卸载（Unloading）

加载、验证、准备和初始化5个阶段，按顺序依次开始（开始依次，过程可能交叉混合进行），解析阶段可能在初始化之后执行。类加载无严格要求，而类初始化有严格条件限定。

初始化阶段有且只有的5种条件（主动引用）：
a. 遇到new、getstatic、putstatic或invokestatic这4条字节指令码时，如果类没有进行过初始化，则需要触发初始化。（场景：new实例化对象、读取或设置一个类的静态字段（被final修饰、已在编译器放入常量池除外）的时候，以及调用一个类静态方法）

b. java.lang.reflect包方法对类进行反射调用；

c. 当初始化一个类时，发现其父类未初始化，初始化父类；

d. 启动虚拟机，指定的执行主类（包含main）方法，先初始化主类；

e. 当使用JDK1.7动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后解析结果REF_getStatic、REF_putStatic、REF_invokeStatic方法句柄，此句柄对应类进行初始化。

除以上情况的引用都是被动引用，不会引发类的初始化。（接口也存在初始化过程，初始化条件与类相似，区别在于第三点，不要求父类初始化，只有真正使用才会初始化）

> P211，查看类不会被初始化的实例，子类调父类值，数组，final

## 流程（详）
### 加载
1. 通过一个类的全限定名来获取定义此类的二进制字节流（从哪里获取、如何获取？）
 1. ZIP包，JAR/EAR/WAR基础；
 2. 网络，Applet；
 3. 运行时计算生成，动态代理技术，java.lang.reflect.Proxy（为特定接口生成具体类）；
 4. 其他文件，jsp技术，jsp文件生成Class类；
 5. 从数据库中读取，例如一些中间件服务器将程序安装到数据库中完成代码在集群中分发；
2. 非数组类由类加载器加载，数组类不是由类加载器加载，有Java虚拟机直接创建，但数组元素类型（ElmentType，指数组去掉所有维度类型）是由类加载器加载，并遵循一些规则。
 1. 如果数组的组件类型（Component Type）是引用类型，递归采用本节定义的加载过程加载此类型，数组C将在加载该组件类型的类加载器的类名称空间上被标识；
 2. 如果非引用类型，与引导类加载器关联；
 3. 数组类型可见性与组件类型一致，如果不是引用类型，默认public。

加载完成后，虚拟机外部二进制字节流按照虚拟机所需的格式存储在方法区中，方法区中存储格式根据虚拟机自定义。然后，实例化一个java.lang.Class类的对象（Class对象位于方法区，此对象作为程序访问方法区类型数据的外部接口）。

### 验证
确保Class文件字节流包含信息符合当前虚拟机要求，并不危害虚拟机本身安全，出错抛出java.lang.VerifyError异常。（由于Class来源的多样性，为防止恶意代码攻击）。

a. 文件格式验证，基于二进制流验证，通过这个阶段验证，字节流才能进入内存方法区存储。

b. 元数据验证，对类的元数据信息进行语义分析校验，是否符合Java规范。

c. 字节码验证，类的方法体进行分析校验，保证方法正确运行。（最复杂耗时的阶段，JDK1.6进行优化，在方法体Code属性添加“StackMapTable"属性，描述方法体中所有基本块（Basic Block，按照控制流拆分的代码块）开始时本地变量表和操作栈应有的状态，将字节码验证的类型推导转变为了类型检查，通过-XX:-UseSplitVerifer关闭，通过-XX:+FailOverToOldVerifer要求验证失败后，按照类型推导方式进行）

d. 符号引用验证，（解析阶段中进行）发生在将符号引用转化为直接引用，对类自身（常量池中的各种符号引用）以外的信息进行匹配，抛出错误：
 - java.lang.IncompatibleClassChangeError
 - java.lang.IllegalAccessError
 - java.lang.NoSuchFieldError
 - java.lang.NoSuchMethodError
 
> 注：如果代码已经经过反复验证，可以通过-Xverify:none，关闭验证，加速类加载。


### 准备
为类变量分配内存并设置类初始值，其中注意实例变量是在对象实例化之后在堆中分配，类变量指static修饰的变量。
```java
public static int value = 123;
```
如上代码，设置初始值为0，赋值为123的操作是putstatic指令，存放于类构造器<clinit>()方法中，在类初始化操作中进行。此外，如果是final修饰的ConstantValue，则在准备阶段直接赋值。

### 解析
虚拟机将常量池内的符号引用替换为直接引用的过程（解析的发生没有规定，可能在类加载器加载后解析，也可能在使用前解析）。
- 符号引用（Symbolic References）：一组符号（任何形式的字面量）描述所引用的目标，无歧义定位到目标，与内存布局无关，引用对象无需加载到内存。（各种虚拟机内存布局不同，符号引用一致，因为其已通过字面量形式定义在Java虚拟机规范的Class文件格式中）
- 直接引用（Direct References）：直接指向目标的指针、相对偏移量或间接定位到目标的句柄，与内存布局有关，引用目标已经出现在了内存中。

指令解析规则，规定在anewarray、checkcast等16个字节码指令操作符号引用前解析，由JVM实现判断是在类被加载时解析，还是使用前解析。

普通符号引用解析，第一次解析进行缓存（在运行时常量池记录直接引用，并将常量表示为已解析状态），后序无需解析；但是invokedynamic指令是动态的，对应的引用称为“动态调用点限定符”（Dynamic Call Site Specifier），每次遇到都会重新解析符号引用。

- 类或接口解析；
如果需要将对类C的符号引用N解析为直接引用，数组和非数组类型不同，解析过程伴随着验证。
 1. 非数组类型，将N的全限定名传递给类加载器D，递归加载，由于验证需要可能加载其他类；
 2. 数组类型，如果数组元素是对象，用正常加载，如果非对象，直接虚拟机生成。
 3. 无异常，C成为有效类或接口，最后进行符号引用验证，如果D无权访问C，抛出java.lang.IllegalAccessError异常。

- 字段解析；
字段符号引用（事先进行类or接口解析），递归搜索解析接口或父类，同时进行权限验证。

- 类方法解析；
事先进行类or接口解析，同上，查找是否有简单名称和描述符都和目标相匹配的方法，有，则返回直接引用，无，则查找失败，NoSuchMethodError。查找到后，检验权限。

- 接口方法解析；
与类方法解析类似，由于接口方法都是public，所以无需检验权限。

类的字节码中常量池存储字面量（如文本字符串、声明为final的常量值等）和符号引用（类/接口全限定名、字段、方法名称和描述符）。由于存储的符号引用是结构信息，并不表示最终内存布局，所以在运行时加载类后需要进行翻译，所以存在解析这一步。

### 初始化
自动生成<clinit>()，执行类构造器<clinit>()实现类初始化。
由编译器自动收集类中的所有类成员变量的赋值动作和静态语句块（static{}块）中语句合并产生（编译器收集顺序是由语句在源文件中出现顺序决定的）。
> 注意：静态语句块能访问定义在之前的静态变量，而定义在之后的静态变量可以赋值，但不能访问。
```java
public class Test{
   static {
	  i=0;
	  System.out.println(i);
    }
	  static int i=1;
}

```
类构造器clinit()方法特性如下：

- clinit()方法是自动收集类中所有类变量赋值动作(static)和静态语句(static{})块合并产生的；
- clinit与类构造函数（init()方法）不同，不需要显式调用父类构造器，而是在子类执行之前，JVM保证父类clinit()执行完毕（所以父类先于子类执行）；
- clinit()方法不是必需的，static可以不存在；
- 对于接口同样会实现clinit()方法，但是与类不同，接口执行clinit()方法无需执行父接口的clinit()方法，只有定义的变量使用时才初始化，而接口实现类clinit()方法执行也无需执行接口clinit()方法。
- 多线程执行clinit()方法，多个线程同时初始化一个线程，只有单个线程执行，其他线程阻塞等待。当这个线程执行clinit()方法完成后，其他线程不会重复执行（只初始化一次）。

## 加载器实现
将类加载阶段的“通过一个类的全限定名来描述此类的二进制字节流”这个动作放到Java虚拟机外部实现，以便让应用程序自己决定如果获取所需类，这个动作称为“类加载器”。类加载器的分类如下：
- 启动类加载器(Bootstrap ClassLoader)，负责加载[JAVA_HOME]\lib目录中(或被-Xbootclasspath指定)，并通过特定文件名加载类库（此类加载器无法被Java程序直接引用，一般用null代替）。

- 扩展类加载器(Extension ClassLoader)，加载[JAVA_HOME]\lib\ext目录(或者java.ext.dirs定义)。

-  应用程序加载器(Application ClassLoader)， 负责加载用户类路径(ClassPath)上指定类库，一般是默认类加载器。

> 注意，判断“类”是否相等的时候，如果同个Class文件中的类，被不同的类加载器加载，则输出类也是不同的（通过instanceof、equals()、isAssignableFrom()、isInstance()）。

### 双亲委派模型
加载器之间的父子关系一般通过组合关系复用。

工作过程：如果一个类加载器收到了类加载请求，首先不会自己加载这个类，而是将请求委派给父加载器加载。如果父加载器无法加载，子加载器才会尝试自己加载。
- 优点
加载的类具备优先级层次关系。（Java库中的类先加载，然后加载用户类，防止造成冲突，如果用户也写了一个java.lang.Object，则不会被加载）

- 缺点
树型结构，自下而上，如果上层基础类需要调用用户的代码，那么启动类加载器无法识别获取。此外，自定义类加载器之间没有关联（无法支持热部署、代码热替换）
注：双亲委派模型的破坏（P233）。

```java
protected synchronized Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException{
 // 查找类是否已经被实现
 Class c = findLoadedClass(name);
 if (c == null){
    try{
       if (parent != null){
        c = parent.loadClass(name, false);
       }else{
        c = findBootstrapClassOrNull(name);
       }
     }catch(ClassNotFoundException e){
      //如果父类加载器抛出ClassNotFoundException
      // 说明父类加载器无法完成加载请求
     }
     if(c == null){
      //在父类加载器无法加载的时候
      //再调用本类加载器加载
      c = findClass(name);
     }
  }
   if(resolve){
    resolveClass(c);
   }
   return c;
}
```



