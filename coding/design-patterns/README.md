# 面向对象思想
## 基础特性
- 继承，定义
    - 优点，
    - 缺点
- 封装

- 多态



## 设计原则
### 单一职责原则(Single Responsibility Principle)<br>
> SRP原话解释，There should never be more than one reason for a class to change.
    
    按照职责来划分类，每个类只有一个职责。这种方式往往会造成以下问题：
    1. 类的数量激增；
    2. 导致类与类之间耦合度较高。<br>
    为了防止这种问题，可以将一个多职责的类去实现不同职责的接口，实现接口的单一职责原则。此外，单一职责原则的应用，对类、接口与方法三者都需要贯彻。

### 里氏替换原则(Liskov Substitution Principle, LSP)<br>
    > If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T, the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.
    
    所有引用父类的地方，必须能透明地使用子类（不会产生错误和异常）。在调用类时必须使用父类或接口，保证代码的健壮性。该原则规定了子类与父类之间的关系：
    - 子类必须完全实现父类的方法。
    > 在子类扩展中，注意子类是否能完整实现父类的业务？
    如果子类不能完整实现父类的业务，或者父类方法已经在子类产生变化，建议断开父子关系，采用依赖、聚集、组合等关系代替继承。
    
    - 子类可以有自己的个性，但是，向下转型是不正确的（用父类替换子类）。
    
    - 覆盖或实现子类方法时，输入参数可以**放大**。参数放大，意味着重载父类的方法，而非重写，同样保证在在父类调用的地方能用子类替换（由于参数放大，会优先调用父类方法）。
    
    > 注意，重载和重写的区别，重载指的是一个具备相同的方法名称，但是参数类型、数量等不同；而重写指的就是子类实现父类的方法。
    
    - 覆写或实现父类的方法时输出结果可以被缩小。当重写时，这是重写规定；当重载时，由于前一条的规定，同样保证子类替换父类，不会出现问题。
    

### 依赖倒置原则（Dependence Inversion Principle, DIP）
    1. 高层模块不能依赖于底层模块，两者都应该依赖于抽象；
    2. 抽象不应该依赖于细节，细节应该依赖于抽象。

 依赖倒置可以降低类之间得耦合性，增加系统稳定性，减少并行开发的风险，提高代码的可读性和可维护性。 抽象可以视为对现实的一种约束，目的是保证所有的细节不脱离契约的范畴。依赖注入的三种方式：
     1. 构造器注入；
     2. Setter方式注入；
     3. 接口声明依赖对象，接口注入。

实践原则：
    1. 每个类尽量有接口或抽象类；（依赖于抽象，首先得有抽象）
    2. 变量的表面类型尽量是接口或者抽象类；（表面类型，定义时赋予的类型；实际类型，实例化的类型）
    3. 任何类都不应该从具体类中派生；（针对开发中）
    4. 尽量不要覆写基类已经实现方法；（基类实现的是共性，修改共性，具备个性，影响稳定性）
    5. 结合里氏替换原则使用。


> 如何验证一个设计的稳定性，通过业务逻辑变更，来验证是否能够应对。
> **面向接口编程**，是依赖倒置的核心。
> **测试驱动开发**，先写好单元测试类，然后再写实现类。


### 接口隔离原则
java中接口主要分为两类，实例接口（Object interface，实现类）和类接口（Class Interface，interface定义的）。给出接口隔离原则定义：
    1. Clients should not be forced to depend upon interfaces that they don't use.（客户端不应该依赖它不需要的接口)
    2. The dependency of one class to another one should depend on the smallest possible interface.（类间的依赖关系应该建立在最小的接口上）
    
    与单一职责原则的区别在于，单一职责原则重点在于接口（业务逻辑）的划分上，而接口隔离原则要求，互相依赖的接口的方法尽量少。

具体含义如下：
    1. 接口尽量小（首先考虑单一职责原则）；
    2. 接口高内聚，减少public方法，减少条件（减少变更风险）；
    3. 定制服务（为不同系统服务，提供不同接口）；
    4. 有限度设计（不能无限拆分接口）。

> 注意：设计是有限度的，不能无限考虑未来的变更情况，否则就会陷入设计的泥潭无法自拔。

实现原则：
    1. 一个接口只服务于一个子模块或业务逻辑；
    2. 经常review；
    3. 已经被污染的接口，尽量修改，如果变更风险大，考虑采用适配器；
    4. 根据环境设计。

### 迪米特法则
迪米特法则（最少知识原则）用于指导类与类之间依赖关系，简单来说，一个类对自己耦合和调用的类知道最少（暴露的接口最少）。主要目的用于类间的解耦。


实践原则：
    1. 一个类中只与朋友交流，不与陌生类交流，类与类之间的关系是建立在类之间的，而不是建立在方法之间的。所以，要求一个方法尽量减少引入一个类中不存在的对象。
    2. 一个类暴露给另一个类的方法（public）数量，表示关系的远近。保持合适的距离，减少不必要的public方法，减小耦合度，提高程序灵活性；
    3. 一个类放置方法的原则：如果一个方法在本类中，不增加类间的关系，不产生负面的影响，可放置在本类中。

> 过度引用迪米特法则的后果，是形成大量的中转类或跳转类。

### 开闭原则(what - why - how?)
Software entities like classes, modules and functions should be open for extension but closed for modifictations.一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。

#### what 
开闭原则，描述的是一种应对变化的原则，是面向对象设计思想的核心。前五种原则，是具体的实践原则，而开闭原则是指导实践的思想。总结应对变化的方式：
1. 修改接口，添加方法（修改契约，大量修改，下下策）；
2. 修改类方法（直接修改类方法，方法语义发生变化，修改较少，下策）；
3. 扩展实现（良策）。

总结一下变化来源：
1. 逻辑变化，业务逻辑发生变化，修改类的方法，前提其他依赖类的操作逻辑变化相同；
2. 子模块变化，底层模块变化，必然影响高层模块；
3. 可见视图变化，用户操作界面发生变化（例如：显示列表多加一列）。

越上层模块发生变化，引起的变动风险越大。

#### why
开闭原则使用的好处：
1. 对测试影响，一个测试类（正常、边界和异常）对应一个业务类。业务类，如果修改方法，也会影响测试类的测试用例，需要进行修改，而这种修改较为复杂与易错的；相反，如果通过扩展一个业务类的方式，新建一个测试类，更加容易操作。
2. 提高复用性，减少代码量，避免相同的逻辑散落在多个角落（减小业务逻辑的粒度）；
3. 提高可维护性，扩展比修改容易；
4. 面向对象的开发要求。

#### how
1. 抽象约束；
    - 通过接口或抽象类约束扩展（对扩展进行边界限定）；
    - 参数类型，要求参数类型与引用对象尽量采用接口或者抽象类；
    - 抽象层尽量维持稳定。
2. 元数据控制模块行为（通过配置文件去控制流程，因为配置文件易修改）；
3. 制定项目章程（团队编程规范）；
4. 封装变化。






# Reference
- 《设计模式之禅》
   
    
    
    