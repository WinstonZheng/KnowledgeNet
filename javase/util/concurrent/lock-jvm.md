# 线程安全性
## 严格定义
当多个线程访问一个对象时，如果不用考虑这些线程运行时环境下的调度与交替运行，也不需要进行额外同步，或者在调用方法进行任何其他的协调工作，调用这个对象的行为可以获得正确的结果，那这个对象就是线程安全的。

## 线程安全等级划分
Java语言操作共享数据线程的安全程度划分（5级）：

1. 不可变
使用final修饰，使变量保持线程可见性，主要不可变对象构造出来（无this引用逃逸），其状态就是不可变的，不会出现线程不一致的情况。
> final修饰基本数据类型，可保证不可变；final修饰引用对象，保证对象的行为不会对对象状态产生影响（类似于String，考虑将对象中所有状态变量都变成final）。

2. 绝对线程安全
就是上一项给出的严格定义，Java中的线程安全类都不是严格定义的，例如：Vector，一个线程写，另一个线程删除，同样会产生错误。

3. 相对线程安全
弱化了绝对的定义，保证对象单个操作时线程安全的，但是针对单个对象的多次操作还是需要同步。

4. 线程兼容
对象本身不是线程安全，但是可以通过某一个些同步手段实现线程安全。（HashMap和ArrayList）

5. 线程对立
即使使用同步，也不能保证线程安全。（两个线程A,B，同时对C采用suspend()和resume()操作）。此外，还由System.setIn()、System.setOut()和System.runFinalizersOnExit()等。

## 实现方法
### 并发策略
- 乐观锁，假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。
- 悲观锁，假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。

> 互斥同步时一种悲观的并发策略，总是认为只要不去做正确的同步措施（例如加锁），那肯定会出现问题，无论共享数据是否真的会出现竞争，都要进行加锁（概念模型）。

### 细节描述
1. 同步互斥，互斥是因，同步时果。
    **同步**指的是在多个线程并发访问数据的时候，保证共享数据在同一时刻只被一个（或者一些）线程使用；**互斥**是实现同步的一种方式，临界区（Critical Section）、互斥量（Mutex）和信号量（Semaphore）。
    - Java中通过synchronized关键字实现，经过编译后同步块前后分别形成monitorenter和monitorexit两个指令码，这两个字节码接受reference类型参数来锁定和解锁对象。（如果有对象输入，则使用对象锁；如果无对象输入，则根据方法类型，实例方法对实例对象，类方法对类对象）
    - ReentrantLock，与synchronized类似，具备线程重入特性，本质上都是互斥锁，增加一些高级功能：
        - 等待可中断，长时间等待，可放弃；
        - 公平锁，多线程等待同一个锁，按照申请锁的时间顺序依次获得锁；
        - 一个ReentrantLock对象可以绑定多个Condition对象（newCondition），而sychronized包含一个隐含条件，但要与多于一个条件关联，需要额外加锁；<br>
> ReentrantLock表现在API层面的互斥锁（lock()和unlock() + try/finally语句块完成）；另一个表现在原生语法层面的互斥。JDK1.6之后，synchronized与ReentrantLock性能基本持平。

2. 非阻塞同步，乐观锁（基于冲突检测），基本思路先进行操作，如果没有冲突，则操作成功；如果产生冲突，采取补偿措施（例如：重试）。乐观锁的实现，需要CPU指令集的支持，因为检测冲突和操作（设置），需要保证原子性，如果采用锁，没有意义（互斥），而CPU提供CAS（Compare and Swap）指令支持。
> **CAS指令**，需要三个操作数，一个内存位置（V），旧的预期值（A），新值（B）。CAS执行时，当V符合旧预期值A时，处理器用新值B更新V的值，否则它不执行更新，该处理过程是一个原子操作。Java中Unsafe类的CAS操作，包括compareAndSet()和getAndIncrement()等方法。
> CAS存在一个**ABA问题**，当第一从V读取到A时，并且准备赋值操作，这期间如果有线程将值从A修改到B，又从B修改到A，那么CAS检测时会假定其没有被修改过。（J.U.C，java并发包，提供了一个AtomicStampedReference，通过控制变量的版本号保证CAS正确性）

3. 无同步代码
 - 可重入代码，一个方法，结果时可预测的，输入相同的数据，返回相同的结果。
 - 线程本地存储，共享数据的代码可否在一个线程内执行。


## sychronized（重量级锁）

synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的Mutex Lock来实现的，而操作系统实现线程之间的切换时需要从用户态转换到核心态。

## 使用
- 修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁
- 修饰类方法(static)，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁
- 修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码块前要获得给定对象的锁。

## 底层实现
重量级锁也就是通常说synchronized的对象锁，锁标识位为10，其中指针指向的是monitor对象（也称为管程或监视器锁）的起始地址。每个对象都存在着一个 monitor 与之关联，对象与其 monitor 之间的关系有存在多种实现方式，如monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个 monitor 被某个线程持有后，它便处于锁定状态。在Java虚拟机(HotSpot)中，monitor是由ObjectMonitor实现。

Hotspot实现ObjectMonitor，维护两个队列，一个EntrySet，一个WaitSet，一个指向获得对象锁线程的指针Owner，线程刚进入竞争线程锁时，进入EntrySet；获取的线程，修改Owner指向该线程，并将计数器count加1；当线程调用wait时，进入WaitSet，清空Owner，count减1；当线程结束，同上，释放锁，其他线程竞争。所以，在java每个对象都能作为锁，而wait()/notify()等方法在Object对象中。（可重入的方式，通过monitor计数器count实现）

> **管程** (英语:Moniters,也称为监视器) 是一种程序结构,结构内的多个子程序(对象或模块)形成的多个工作线程互斥访问共享资源。这些共享资源一般是硬件设备或一群变量。管程实现了在一个时间点,最多只有一个线程在执行管程的某个子程序。与那些通过修改数据结构实现互斥访问的并发程序设计相比,管程实现很大程度上简化了程序设计。管程提供了一种机制,线程可以临时放弃互斥访问,等待某些条件得到满足后,重新获得执行权恢复它的互斥访问。

### sychronized代码块
字节码时通过monitorenter 和 monitorexit 指令圈定同步块。（编译器将会确保无论方法通过何种方式完成，方法中调用过的每条 monitorenter 指令都有执行其对应 monitorexit 指令，而无论这个方法是正常结束还是异常结束。编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行 monitorexit 指令。）

### sychronized方法
JVM可以从方法常量池中的方法表结构(method_info Structure) 中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法。

## 锁优化
高效并发是从JDK1.5到JDK1.6的一个重要改进。

### 自旋锁
由于线程调度的高开销，当遇到线程竞争时，如果在物理机器上具备一个以上的处理器，能让两个或者以上的线程同时执行，那么让请求锁的线程执行一个忙循环（自旋），这就是所谓的**自旋锁**。

自旋锁的自适应自旋（JDK1.6），指的是根据同一锁上一次自旋时间及锁的拥有者的状态来决定自旋时间。如果拥有锁的线程正在执行，而上次自旋等待成功获得锁，那么允许长时间的自旋；如果很少有机会通过自旋获得锁，那么省略自旋过程。

> 通过-XX:PreBlockSpin更改

### 锁消除
根据逃逸分析的数据支持，如果对象不会存在逃逸出本线程的可能，那么，可以消除锁（主要针对Java类库中提供的同步操作）。

> 逃逸分析，基本行为是分析对象的动态作用域。其中，线程逃逸指的是，对象是否可能被外部线程访问到，例如通过赋值给类变量或者可以在其他线程中访问实例变量。

### 锁粗化
如果一系列连续操作都对同一个对象仿佛加锁、解锁，或者同步操作出现在循环中，JVM会将锁同步操作扩展到整个操作序列的外部。

### 轻量级锁
本意，在于在没有多线程竞争的前提下，减少传统的重量级锁使用用，减少操作系统的互斥量产生的性能消耗。

Java的对象头部根据不同的存储锁标志位Mark Word，来存储不同的内容：
- 01 ，未锁定，对象哈希码、对象分代年龄
- 00 ，轻量级锁定，指向锁记录的指针；
- 10， 膨胀，指向重量级锁的指针；
- 11，GC标记，空；
- 01， 可偏向，偏向线程ID、偏向时间戳、对象分代年龄。

当代码进入同步快时候，处于01状态，JVM首先在栈帧中建立一个锁记录（Lock Record）的空间，用于存储Mark Word的拷贝（Displaced Mark Word）。然后，使用CAS操作，修改Mark Word为指向Lock Record的指针，如果成功，则将状态转变为00；如果失败，则说明对象被抢占，则Mark Word转化成指向互斥量的指针。

轻量级锁的解锁过程，通过CAS操作，旧值为指向Displaced Mark Word的地址，新值为01状态下存储的值，如果成果替换，则解锁成功；如果失败，则说明其他线程尝试获得该锁，则释放锁同时，唤醒被挂起的线程。

> 进行了额外的CAS操作，存在额外的性能开销，如果，一定由线程竞争，轻量级锁的性能比重量级锁更慢。

![](/images/java/concureent/light-lock.jpg)

### 偏向锁
目的在于消除无竞争条件下的同步原语。偏向锁与轻量级锁区别在于，轻量级锁是消除互斥量，而偏向锁是在没有竞争的条件下把整个锁都消除掉。

类似于轻量级锁，偏向锁通过CAS操作，将取到这个锁的ID记录在Mark Word中，每次该线程访问这个同步块，都不需要进行同步操作（Locking、Unlocking以及对Mark Word的Update等）。如果当另一个线程访问偏向锁，则撤销偏向后恢复到轻量级锁定或者未锁定状态，后续同步操作按照轻量级锁那样执行。

- 偏向锁的撤销，需要等待到全局安全点（没有正在执行字节码），它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，
    - 如果线程不处于活动状态，则将对象头设置成无锁状态，然后重新偏向其它线程，
    - 如果线程仍然活动着，检查该对象的使用情况，如果仍然需要持有偏向锁，则偏向锁升级为轻量级锁（两个线程同时采用CAS操作，竞争，成功获得资源，失败进入自旋,自旋失败，锁膨胀）。如果不存在使用了，则重新变为无锁状态，然后重新偏向。
- 最后唤醒暂停的线程。

![](/images/java/concureent/lock.jpg)

线程切换图如下：

![](/images/java/concureent/bisa-lock.jpg)



> 当对象处于锁定的状态时，其的hashcode、age等信息存储在线程私有的结构Monitor Record中，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表；每一个被锁住的对象都会和一个monitor record关联（对象头中的LockWord指向monitor record的起始地址，由于这个地址是8byte对齐的所以LockWord的最低三位可以用来作为状态位），同时monitor record中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。



# Reference
- [图来源](https://blog.csdn.net/fouy_yun/article/details/77816949)
- [synchronized](https://blog.csdn.net/javazejian/article/details/72828483#synchronized%E7%9A%84%E4%B8%89%E7%A7%8D%E5%BA%94%E7%94%A8%E6%96%B9%E5%BC%8F)
- 《深入理解Java虚拟机》