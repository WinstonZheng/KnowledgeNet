# Semaphore
Semaphore的实现思路类似于ReetrantLock，都是基于AQS的同步队列管理操作。不过，实现的思路不同，ReetrantLock时通过CAS的改变01状态方式，进行加锁和解锁操作；而Semaphore会在初始的时候给state赋一个正值，每次加锁通过CAS加循环补偿的方式减少state的操作，而解锁操作类似，也是通过循环补偿，增加state的值。

实现的思路也类似，通过Sync实现共享锁的加锁解锁操作，而NonfairSync和FairSync分别实现了不同的加锁方式。




## 基本操作

在AQS中存在一个变量state，当我们创建Semaphore对象传入许可数值时，最终会赋值给state，state的数值代表同一个时刻可同时操作共享数据的线程数量，每当一个线程请求(如调用Semaphored的acquire()方法)获取同步状态成功，state的值将会减少1，直到state为0时，表示已没有可用的许可数，也就是对共享数据进行操作的线程数已达到最大值，其他后来线程将被阻塞，此时AQS内部会将线程封装成共享模式的Node结点，加入同步队列中等待并开启自旋操作。只有当持有对共享数据访问权限的线程执行完成任务并释放同步状态后，同步队列中的对于的结点线程才有可能获取同步状态并被唤醒执行同步操作，注意在同步队列中获取到同步状态的结点将被设置成head并清空相关线程数据(毕竟线程已在执行也就没有必要保存信息了)，AQS通过这种方式便实现共享锁。至于公平锁与非公平锁的不同之处在于公平锁会在线程请求同步状态前，判断同步队列是否存在Node，如果存在就将请求线程封装成Node结点加入同步队列，从而保证每个线程获取同步状态都是先到先得的顺序执行的。非公平锁则是通过竞争的方式获取，不管同步队列是否存在Node结点，只有通过竞争获取就可以获取线程执行权。




