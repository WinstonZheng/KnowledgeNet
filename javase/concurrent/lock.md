# 线程安全与锁优化

## 严格定义
当多个线程访问一个对象时，如果不用考虑这些线程运行时环境下的调度与交替运行，也不需要进行额外同步，或者在调用方法进行任何其他的协调工作，调用这个对象的行为可以获得正确的结果，那这个对象就是线程安全的。

## 线程安全等级划分
Java语言操作共享数据线程的安全程度划分（5级）：

1. 不可变
使用final修饰，使变量保持线程可见性，主要不可变对象构造出来（无this引用逃逸），其状态就是不可变的，不会出现线程不一致的情况。
> final修饰基本数据类型，可保证不可变；final修饰引用对象，保证对象的行为不会对对象状态产生影响（类似于String，考虑将对象中所有状态变量都变成final）。

2. 绝对线程安全
就是上一项给出的严格定义，Java中的线程安全类都不是严格定义的，例如：Vector，一个线程写，另一个线程删除，同样会产生错误。

3. 相对线程安全
弱化了绝对的定义，保证对象单个操作时线程安全的，但是针对单个对象的多次操作还是需要同步。

4. 线程兼容
对象本身不是线程安全，但是可以通过某一个些同步手段实现线程安全。（HashMap和ArrayList）

5. 线程对立
即使使用同步，也不能保证线程安全。（两个线程A,B，同时对C采用suspend()和resume()操作）。此外，还由System.setIn()、System.setOut()和System.runFinalizersOnExit()等。

## 实现方法
### 并发策略
- 乐观锁，假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。
- 悲观锁，假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。

> 互斥同步时一种悲观的并发策略，总是认为只要不去做正确的同步措施（例如加锁），那肯定会出现问题，无论共享数据是否真的会出现竞争，都要进行加锁（概念模型）。

### 细节描述

1. 同步互斥，互斥是因，同步时果。
    **同步**指的是在多个线程并发访问数据的时候，保证共享数据在同一时刻只被一个（或者一些）线程使用；**互斥**是实现同步的一种方式，临界区（Critical Section）、互斥量（Mutex）和信号量（Semaphore）。
    - Java中通过synchronized关键字实现，经过编译后同步块前后分别形成monitorenter和monitorexit两个指令码，这两个字节码接受reference类型参数来锁定和解锁对象。（如果有对象输入，则使用对象锁；如果无对象输入，则根据方法类型，实例方法对实例对象，类方法对类对象）
    - ReentrantLock，与synchronized类似，具备线程重入特性，本质上都是互斥锁，增加一些高级功能：
        - 等待可中断，长时间等待，可放弃；
        - 公平锁，多线程等待同一个锁，按照申请锁的时间顺序依次获得锁；
        - 一个ReentrantLock对象可以绑定多个Condition对象（newCondition），而sychronized包含一个隐含条件，但要与多于一个条件关联，需要额外加锁；<br>
> ReentrantLock表现在API层面的互斥锁（lock()和unlock() + try/finally语句块完成）；另一个表现在原生语法层面的互斥。JDK1.6之后，synchronized与ReentrantLock性能基本持平。

2. 非阻塞同步，乐观锁（基于冲突检测），基本思路先进行操作，如果没有冲突，则操作成功；如果产生冲突，采取补偿措施（例如：重试）。乐观锁的实现，需要CPU指令集的支持，因为检测冲突和操作（设置），需要保证原子性，如果采用锁，没有意义（互斥），而CPU提供CAS（Compare and Swap）指令支持。
> **CAS指令**，需要三个操作数，一个内存位置（V），旧的预期值（A），新值（B）。CAS执行时，当V符合旧预期值A时，处理器用新值B更新V的值，否则它不执行更新，该处理过程是一个原子操作。Java中Unsafe类的CAS操作，包括compareAndSet()和getAndIncrement()等方法。
> CAS存在一个**ABA问题**，当第一从V读取到A时，并且准备赋值操作，这期间如果有线程将值从A修改到B，又从B修改到A，那么CAS检测时会假定其没有被修改过。（J.U.C，java并发包，提供了一个AtomicStampedReference，通过控制变量的版本号保证CAS正确性）

3. 无同步代码
 - 可重入代码，一个方法，结果时可预测的，输入相同的数据，返回相同的结果。
 - 线程本地存储，共享数据的代码可否在一个线程内执行。


## 锁优化
高效并发是从JDK1.5到JDK1.6的一个重要改进。

### 自旋锁
由于线程调度的高开销，当遇到线程竞争时，如果在物理机器上具备一个以上的处理器，能让两个或者以上的线程同时执行，那么让请求锁的线程执行一个忙循环（自旋），这就是所谓的**自旋锁**。

自旋锁的自适应自旋（JDK1.6），指的是根据同一锁上一次自旋时间及锁的拥有者的状态来决定自旋时间。如果拥有锁的线程正在执行，而上次自旋等待成功获得锁，那么允许长时间的自旋；如果很少有机会通过自旋获得锁，那么省略自旋过程。

> 通过-XX:PreBlockSpin更改

### 锁消除
根据逃逸分析的数据支持，如果对象不会存在逃逸出本线程的可能，那么，可以消除锁（主要针对Java类库中提供的同步操作）。

> 逃逸分析，基本行为是分析对象的动态作用域。其中，线程逃逸指的是，对象是否可能被外部线程访问到，例如通过赋值给类变量或者可以在其他线程中访问实例变量。

### 锁粗化
如果一系列连续操作都对同一个对象仿佛加锁、解锁，或者同步操作出现在循环中，JVM会将锁同步操作扩展到整个操作序列的外部。

### 轻量级锁
本意，在于在没有多线程竞争的前提下，减少传统的重量级锁使用用，减少操作系统的互斥量产生的性能消耗。

Java的对象头部根据不同的存储锁标志位Mark Word，来存储不同的内容：
- 01 ，未锁定，对象哈希码、对象分代年龄
- 00 ，轻量级锁定，指向锁记录的指针；
- 10， 膨胀，指向重量级锁的指针；
- 11，GC标记，空；
- 01， 可偏向，偏向线程ID、偏向时间戳、对象分代年龄。

当代码进入同步快时候，处于01状态，JVM首先在栈帧中建立一个锁记录（Lock Record）的空间，用于存储Mark Word的拷贝（Displaced Mark Word）。然后，使用CAS操作，修改Mark Word为指向Lock Record的指针，如果成功，则将状态转变为00；如果失败，则说明对象被抢占，则Mark Word转化成指向互斥量的指针。

轻量级锁的解锁过程，通过CAS操作，旧值为指向Displaced Mark Word的地址，新值为01状态下存储的值，如果成果替换，则解锁成功；如果失败，则说明其他线程尝试获得该锁，则释放锁同时，唤醒被挂起的线程。

> 进行了额外的CAS操作，存在额外的性能开销，如果，一定由线程竞争，轻量级锁的性能比重量级锁更慢。

![](/images/java/concureent/light-lock.jpg)

### 偏向锁
目的在于消除无竞争条件下的同步原语。偏向锁与轻量级锁区别在于，轻量级锁是消除互斥量，而偏向锁是在没有竞争的条件下把整个锁都消除掉。

类似于轻量级锁，偏向锁通过CAS操作，将取到这个锁的ID记录在Mark Word中，每次该线程访问这个同步块，都不需要进行同步操作（Locking、Unlocking以及对Mark Word的Update等）。如果当另一个线程访问偏向锁，则撤销偏向后恢复到轻量级锁定或者未锁定状态，后续同步操作按照轻量级锁那样执行。

- 偏向锁的撤销，需要等待到全局安全点（没有正在执行字节码），它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，
    - 如果线程不处于活动状态，则将对象头设置成无锁状态，然后重新偏向其它线程，
    - 如果线程仍然活动着，检查该对象的使用情况，如果仍然需要持有偏向锁，则偏向锁升级为轻量级锁（两个线程同时采用CAS操作，竞争，成功获得资源，失败进入自旋,自旋失败，锁膨胀）。如果不存在使用了，则重新变为无锁状态，然后重新偏向。
- 最后唤醒暂停的线程。

![](/images/java/concureent/lock.jpg)

线程切换图如下：

![](/images/java/concureent/bisa-lock.jpg)



> 当对象处于锁定的状态时，其的hashcode、age等信息存储在线程私有的结构Monitor Record中，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表；每一个被锁住的对象都会和一个monitor record关联（对象头中的LockWord指向monitor record的起始地址，由于这个地址是8byte对齐的所以LockWord的最低三位可以用来作为状态位），同时monitor record中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。



# Reference
- [图来源](https://blog.csdn.net/fouy_yun/article/details/77816949)