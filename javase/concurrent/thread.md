# 线程

线程是比进程跟轻量级的调度执行单位，主流操作系统提供线程实现，

## 实现
- 内核线程实现；
    在支持多线程内核中，采用用户空间轻量级进程和内核空间线程1：1的映射关系实现；
    - 优点：实现简单，调度灵活；
    - 缺点：线程的创建、销毁及同步，需要系统调用，用户和内核空间切换，消耗性能和内核资源；
    
- 用户线程实现；
    用户线程的建立、同步、销毁和调度完全在用户态中实现，无需内核，实现方式一对多，1：N。
    - 优点：性能好；
    - 缺点：实现复杂。
    
- 用户线程加轻量级进程混合实现；
    使用内核线程与用户线程结合，用户线程创建、切换、析构等操作廉价，支持大规模用户线程并发。通过操作系统提供的轻量级进程连接用户线程与内核线程，用户线程的系统调用通过轻量级进程实现，线程调度功能及处理器映射（访问），N:M。
    

### Java线程实现
JDK1.2以前，基于称为"Green Threads"的用户线程实现；在JDK1.2中，线程模型替换为基于操作系统的原生线程模型实现。具体的虚拟机线程模型实现，根据不同的操作系统底层与不同的虚拟机JDK有关。其中，对于Sun JDK其Windows版与Linux版都是使用一对一线程模型实现的，一条JAVA线程映射到一条轻量级进程中。而在Solaris平台中，平台支持一对一及多对多，提供两个平台专有虚拟机参数：-XX:+UseLWPSynchronization（默认）和-XX:+UseBoundThreads指明使用哪一种线程模型。

> 注意：从上面实现来看，Java的线程实现要不采用内核线程实现，要不采用混合实现，但是两种都有一个特点，如果线程状态变化，都是通过操作系统的系统调度实现，也就意味着加锁阻塞是一种非常耗时的操作。


## Java线程调度
### 调度分类
主要分为协同式调度（Cooperative Threads-Scheduling）和抢占式调度（Preemptive Threads-Scheduling）。
- 协同式调度，线程执行时间由线程本身控制，线程的调度由线程本身执行完成后通知调度器调度。（不稳定，如果线程一直阻塞，出现饿死的情况）
- 抢占式调度，由系统分配执行时间，线程切换由系统控制。

Java中采用抢占式调度，可以通过Thread.yield()出让执行时间，还可以通过设置优先级可能改变线程调度先后顺序（由于10个优先级和底层系统线程优先级数量不一致，可能造成多对一的情况）。

### 线程状态转换
线程主要分为五中状态：
- 新建，New，Thread创建，但并未执行；
- 运行，Runnable，Thread.start()之后，可能执行，可能就绪；
- 无限期等待，Waiting，Object.wait()/Thread.join()/LockSupport.park()方法，没有设置超时时间；
- 限期等待，TimeWaiting，Thread.sleep()/Object.wait(timeout)/Thread.join(timeout)/LockSupport.parkNanos()/LockSupport.parkUntil()方法，超时等待；
- 阻塞，Blocked，阻塞状态等待一个排他锁；
- 结束，Terminated，线程结束。




# Reference
- 《深入理解Java虚拟机》





