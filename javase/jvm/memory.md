# 垃圾收集器
学习垃圾收集器，首先考虑两个关键，垃圾和收集。垃圾，何谓垃圾？如何定位垃圾？收集，如何去收集，收集的思路和具体的实现是什么？

垃圾，所谓垃圾，指的是已经不被程序占用的内存，在Java中，通过引用来使用内存，那么简单来说，垃圾就是没有被引用的内存。（程序计数器、虚拟机栈和本地方法栈随着线程创建和销毁，所以垃圾收集一般针对堆和native内存）

## 如何判定垃圾需要回收？
对象标记的方法分类：

- 简单的方法：引用计数法，计数器记录当前引用的数量，计数器为0，对象不可用（互相引用，出现问题）。
- 可达性分析，以GC Root作为根，判断通过GC Root是否可以到达对象。一般可作为GC Root的对象（why?）：
    1. 虚拟机栈（栈帧中的本地变量表）中引用的对象；
    2. 方法去中类静态属性引用的对象；
    3. 方法区中常量引用的对象；
    4. 本地方法栈中JNI（Native方法）引用对象。
    
> 所谓“GC roots”，或者说tracing GC的“根集合”，就是一组必须活跃的引用。GC roots这组引用是tracing GC的起点。要实现语义正确的tracing GC，就必须要能完整枚举出所有的GC roots，否则就可能会漏扫描应该存活的对象，导致GC错误回收了这些被漏扫的活对象。

两次标记算法：	
1. 如果检测到对象无连接到GC Root的引用链，进行第一次标记，检测finalize()方法，如果没有覆盖或已经执行了，则直接回收；
2. 如果需要执行finalize()，则放置到F-Queue队列中，由JVM自动建立低优先级的Finalizer线程执行（不保证finalize执行完成）。针对F-Queue队列进行第二次标记，如果finalize()中对象被链接，则移出队列，否则将其回收。（对于任何对象的finalize只会被调用一次）

> 不建议使用finalize()方法，如果finalize()方法效率过低，则影响垃圾回收效率。


### 引用分类
JDK1.2以后提供的引用方式从强到弱：强引用/软引用（内存溢出之前，进行二次回收的对象）/弱引用（存活到下一次垃圾收集发生之前）/虚引用（被回收时，发出一个系统通知）


### 方法区的回收
方法区回收：
1. 废弃常量（无任何实例引用）；
2. 无用的类。
	1. java堆中类的所以实例已经被回收；
	2. 加载该类的ClassLoader被回收；
	3. 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载功能。

## 垃圾收集思路？
垃圾收集的算法。

1. “标记-清除”算法
    首先标记需要清除对象，在标记完成后统一清除。
    缺点：1. 效率低；2. 空间不连续，产生内存碎片，无法分配大对象。

2. 复制算法
划分为左右两个部分，先使用其中一部分（移动堆顶指针），这一部分用完，将存活对象复制到另外一部分，再继续分配，清空原先的部分。（改进：比例不用1：1，可以划分为一块较大的内存Eden和一块较小的内存Survivor，回收时将存活对象复制到小内存中，并需要一部分内存（老年代）作为担保）
    - 优点：高效垃圾收集，无碎片产生；
    - 缺点：缩小一半内存（存活率较高情况下，复制代价高）。
    
3. 标记-整理算法
针对老年代存活率较高的情境下，使用标记对象，然后将存活对象向一端移动，清除端边界以外的内存。

4. 分代收集算法
新生代使用复制算法，进行少量对象复制成本，快速清理垃圾（存活率低，需要有担保）；
老年代使用标记整理（清理）算法，清理垃圾（存活率高，无担保）；


## 垃圾收集具体实现（HotSpot）？

### 枚举根节点：
需要通过所有根节点的可达性分析，用以标记可回收对象。可以推断，为了防止引用变化，在枚举根节点时，将所有的线程中断（停顿），如果枚举根节点的时间过长，会严重影响性能。
    - 优化，Hotspot通过OopMap的数据结构加速枚举的过程，在类加载完成时，HotSpot会计算并记录对象中不同类型数据位置，GC通过直接扫描可以获取信息。（空间换时间）
    - 缺点弥补，如果OopMap针对每个指令都记录，则耗费过多的空间存储，所以，只在“安全点”（safepoint）记录对应信息。而“安全点”的选择则是根据“是否让程序长时间执行的特征”（指令序列的复用，方法跳转、循环跳转等）

#### 多线程的安全点
面对多线程的情况下，如何将线程都跑到安全点，有两种方案可以选择：

1. 抢先式中断，中断所有线程，如果有线程未到安全点，则恢复线程运行到安全点。（很少使用，why? 个人猜测：性能原因，中断所有线程并检测，会影响所有线程执行时间，如果一个线程需要长时间执行才到safepoint呢，而主动式，不影响其他线程执行）。
2. 主动式中断，不针对线程操作，设置标志（安全点），由各个线程主动轮询。当需要中断，将内存也设置不可读，线程产生一个自陷异常信号，在异常处理器中暂停线程实现等待。（安全点轮询和出发线程中断）

#### 安全区
当一个线程长时间sleep或blocked状态，需要解决GC问题
安全区域指的是一段代码片段中，引用关系不会发生变化。在这块区域GC是安全的。当进入安全区域，进行标记；离开时，需要GC完成（或枚举过程结束）信号才能离开。

### 垃圾收集器
- 新生代收集器：Serial、ParNew、Parallel Scavenge；
- 老年代收集器：Serial Old、Parallel Old、CMS；
- 整堆收集器：G1；

#### Serial收集器
单线程收集垃圾，暂停其他所有线程。
- 简介
    GC线程（新生代使用复制算法）-> 其他线程 -> GC线程（老年代采用标记-整理算法）
    （新生代较小情况下，单线程收集效率较高，无线程之间交互）
    
- 使用场景 
    单CPU，Client模式，内存较小，停顿短。
    
- 参数设置
    -XX:+UseSerialGC：添加该参数来显式的使用串行垃圾收集器；

#### ParNew收集器（针对多个CPU）
多线程收集垃圾（控制参数、收集算法、Stop The World、对象分配规则、回收策略等与Serial完全一样），只是采用多条线程收集垃圾。

- 使用场景
在Server模式下（多CPU），ParNew收集器是一个非常重要的收集器，因为除Serial外，目前只有它能与CMS收集器配合工作；但在单个CPU环境中，不会比Serail收集器有更好的效果，因为存在线程交互开销。

- 设置参数
使用-XX:+UseParNewGC强制指定，或者使用-XX:+UseConcMarkSweepGC的默认新生代收集器，使用-XX:ParallelGCThreads控制垃圾收集的线程数。


#### Parallel Scavenge收集器


#### Serial Old收集器

#### Parallel Old收集器


#### CMS收集器

#### G1收集器



# java内存模型




# Reference
- [垃圾收集器](https://blog.csdn.net/tjiyu/article/details/53983650)