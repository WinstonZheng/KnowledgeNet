# Java内存模型
Java内存模型（Java Memory Model, JMM）主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节（实例字段、静态字段和构成数组对象元素，会产生竞争）。

Java内存模型屏蔽了各种硬件和操作系统的内存访问差异，提供访问的一致性，JDK1.5发布后，Java内存模型已经成熟和完善起来。

## 特征
- 原子性，保证变量基本操作的原子性（read、load等），提供各大范围的原子性（lock、unlock）；
- 可见性，当一个线程修改了共享变量的值，其他线程能够立即可见；
  - volatile；
  - synchronized，unlock之前变量同步会主内存；
  - final，如果在构造器中初始化，则能被其他线程正确访问；
- 有序性，如果在本线程内观察，所有操作是有序的，如果在一个线程内观察另外一个线程，所有操作都是无序的。

> this引用逃逸
当类中构造完成一半时，在构造器中启动另一个线程访问对象的变量（变量初始化，在线程启动之后），可能取出空值。



## 内存划分
Java内存模型规定了所有变量都存储在主内存（Main Memory），每条线程有自己的工作内存（Work Memory，类似与处理器高速缓存），保存主内存副本拷贝（可能知识对象一个属性）。

- 主内存 -> JAVA堆
- 工作内存 -> JAVA栈

## 内存操作
主内存与工作内存之间具体操作协议（JSR-133弃用）
- lock（锁定），作用于主内存变量，将变量标识为一条线程独占状态；
- unlock（解锁），作用于主内存变量，将处于锁定状态的变量释放出来；
- read（读取），作用于主内存变量，将一个变量值从主内存传输到工作内存；
- load（载入）作用于工作内存变量，将read的值放置到工作内存变量副本；
- use（使用），作用于工作内存**，将变量传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码时执行；
- assign（赋值），作用于工作内存**，将从执行引擎接到的值赋给工作内存变量，遇到赋值操作执行；
- store（存储），作用于工作内存**，将工作内存变量传递给主内存；
- write （写入），作用于主内存**，将store的变量放到主内存变量中。

### 基本执行规则
基础描述暂不提供（见《深入理解java虚拟机》），主要提供等效判断原则----先行发生原则（用于确定一个访问在并发环境下时安全的）。

判断数据是否存在竞争、线程是否安全的主要依据。
- 程序次序规则(Program Order Rule）：在一个线程内，按照程序代码顺序，写在前面的操作先行发生于写在后面的操作（控制流顺序，考虑分支、循环）。
- 管程锁定原则（Monitor Lock Rule）：一个unlock操作先行发生于后面对同一个锁的lock操作；（包括时间先后）
- volatile变量规则（Volatile Variable Rule）：对于一个volatile变量写操作先行发生于后面对这个变量的读操作；（包括时间先后）
- 线程启动规则（Thread Start Rule）：Thread的start()操作先行发生于此线程中每个操作；
- 线程终止规则（Thread Termination Rule）：线程中所有操作都先行发生于对此线程的终止检测（通过Thread.join()、Thread.isAlive()检测线程终止）；
- 线程中断规则（Thread Interruption Rulle）:对线程的interrupt()方法调用先行发生于被中断线程的代码检测到中断事件的发生；
- 对象终结规则（Thread Interruption Rule）：一个对象初始化完成（构造函数执行结束），先行发生于它的finalize()方法开始；
- 传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那么操作A先行发生于操作C。

> 注意：时间顺序和先行顺序无太大关系，典型案例，在一个线程中的两个变量赋值，顺序可能多变。






### volatile规则
volatile是java并发最轻量级的同步机制。

使用场景
1. 运算结果并不依赖与当前值；
2. 确保只有一条线程在修改值；
3. 变量不需要与其他变量共同参与不变约束。 

volatile修饰的关键字由如下两种特性。


#### 保证此变量对所有线程的可见性
  在考虑实现之前，volatile修饰的变量并不是严格的线程安全的，当由多个线程修改该变量，同样能导致不一致的情况出现。首先，理解线程不安全，由于每个线程由单独的工作内存，工作内存修改的变量不会实时与主内存同步，所以多线程操作可能存在不一致的情况。
  
- 如何实现？
  volatile保证了线程工作内存中的该变量在使用前，需要先从主内存加载；而修改后，立即写回到主内存中。但是，尽管如此，也不能保证多线程修改的安全性。
  
#### 禁止指令重排序
- 概念
  - 指令重排
  从硬件的架构角度理解，指令重排序是指CPU采用允许多条指令不按照程序规定的顺序分开发给各个相应电路单元处理，此外，重排的指令应该是互相没有依赖关系（CPU控制指令依赖）。
  
  - 内存屏障（Memory Barrier or Memory Fence）
  指重排序时，不能把后面的指令重排序到内存屏障之前的位置。实现的思路，考虑指令重排的概念，CPU通过lock指令设置屏障，当CPU运行到lock指令，会将CPU内的修改全部同步到内存中，所以造成了屏障效果。

- 如何实现？
  volatile修饰的变量在使用或者修改时，造成了内存屏障的效果。
    
> volatile的开销比锁低

#### 规则描述
volatile修饰变量遵循以下原则：
1. use与load需要按顺序连续一起出现（每次使用前从主内存刷新值）；
2. assign与store需要连续一起出现（修改后，必须同步回内存）；
3. 禁止指令优化，保证代码顺序与程序顺序相同。





# 扩展知识
## 指令重排

- 编译器优化的重排，编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。

- 指令并行的重排，现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性(即后一个执行的语句无需依赖前面执行的语句的结果)，处理器可以改变语句对应的机器指令的执行顺序

- 内存系统的重排，由于处理器使用缓存和读写缓存冲区，这使得加载(load)和存储(store)操作看上去可能是在乱序执行，因为三级缓存的存在，导致内存与缓存的数据同步存在时间差。




# Reference
- [全面理解Java内存模型(JMM)及volatile关键字](https://blog.csdn.net/javazejian/article/details/72772461)


