# Java内存模型
Java内存模型（Java Memory Model, JMM）主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节（实例字段、静态字段和构成数组对象元素，会产生竞争）。

Java内存模型屏蔽了各种硬件和操作系统的内存访问差异，提供访问的一致性，JDK1.5发布后，Java内存模型已经成熟和完善起来。

## 特征
- 原子性，保证变量基本操作的原子性（read、load等），提供各大范围的原子性（lock、unlock）；
- 可见性，当一个线程修改了共享变量的值，其他线程能够立即可见；
  - volatile；
  - synchronized，unlock之前变量同步会主内存；
  - final，如果在构造器中初始化，则能被其他线程正确访问；
- 有序性，如果在本线程内观察，所有操作是有序的，如果在一个线程内观察另外一个线程，所有操作都是无序的。

> this引用逃逸
当类中构造完成一半时，在构造器中启动另一个线程访问对象的变量（变量初始化，在线程启动之后），可能取出空值。



## 内存划分
Java内存模型规定了所有变量都存储在主内存（Main Memory），每条线程有自己的工作内存（Work Memory，类似与处理器高速缓存），保存主内存副本拷贝（可能知识对象一个属性）。

- 主内存 -> JAVA堆
- 工作内存 -> JAVA栈

## 内存操作
主内存与工作内存之间具体操作协议（JSR-133弃用）
- lock（锁定），作用于主内存变量，将变量标识为一条线程独占状态；
- unlock（解锁），作用于主内存变量，将处于锁定状态的变量释放出来；
- read（读取），作用于主内存变量，将一个变量值从主内存传输到工作内存；
- load（载入）作用于工作内存变量，将read的值放置到工作内存变量副本；
- use（使用），作用于工作内存**，将变量传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码时执行；
- assign（赋值），作用于工作内存**，将从执行引擎接到的值赋给工作内存变量，遇到赋值操作执行；
- store（存储），作用于工作内存**，将工作内存变量传递给主内存；
- write （写入），作用于主内存**，将store的变量放到主内存变量中。

### 基本执行规则
基础描述暂不提供（见《深入理解java虚拟机》），主要提供等效判断原则----先行发生原则（用于确定一个访问在并发环境下时安全的）。Happens-before的前后两个操作不会被重排序且后者对前者的内存可见。

判断数据是否存在竞争、线程是否安全的主要依据。

- 程序次序规则(Program Order Rule）：在一个线程内，按照程序代码顺序，写在前面的操作先行发生于写在后面的操作（控制流顺序，考虑分支、循环）。

- 管程锁定原则（Monitor Lock Rule）：一个unlock操作先行发生于后面对同一个锁的lock操作，（包括时间先后）也就是说，如果对于一个锁解锁后，再加锁，那么加锁的动作必须在解锁动作之后(同一个锁)。

- volatile变量规则（Volatile Variable Rule）：对于一个volatile变量写操作先行发生于后面对这个变量的读操作，（包括时间先后）这保证了volatile变量的可见性，**简单的理解**就是，volatile变量在每次被线程访问时，都强迫从主内存中读该变量的值，而当该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，不同的线程总是能够看到该变量的最新值。

- 线程启动规则（Thread Start Rule）：Thread的start()操作先行发生于此线程中每个操作；即如果线程A在执行线程B的start方法之前修改了共享变量的值，那么当线程B执行start方法时，线程A对共享变量的修改对线程B可见。

- 线程终止规则（Thread Termination Rule）：线程中所有操作都先行发生于对此线程的终止检测（通过Thread.join()、Thread.isAlive()检测线程终止）；假设在线程B终止之前，修改了共享变量，线程A从线程B的join方法成功返回后，线程B对共享变量的修改将对线程A可见。

- 线程中断规则（Thread Interruption Rulle）:对线程的interrupt()方法调用先行发生于被中断线程的代码检测到中断事件的发生；

- 对象终结规则（Thread Interruption Rule）：一个对象初始化完成（构造函数执行结束），先行发生于它的finalize()方法开始；

- 传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那么操作A先行发生于操作C。

> 注意：时间顺序和先行顺序无太大关系，典型案例，在一个线程中的两个变量赋值，顺序可能多变。



### volatile规则
volatile是java并发最轻量级的同步机制。

使用场景
1. 运算结果并不依赖与当前值；
2. 确保只有一条线程在修改值；
3. 变量不需要与其他变量共同参与不变约束。 

volatile修饰的关键字由如下两种特性。


#### 保证此变量对所有线程的可见性
  在考虑实现之前，volatile修饰的变量并不是严格的线程安全的，当由多个线程修改该变量，同样能导致不一致的情况出现。首先，理解线程不安全，由于每个线程由单独的工作内存，工作内存修改的变量不会实时与主内存同步，所以多线程操作可能存在不一致的情况。
  
- 如何实现？
  volatile保证了线程工作内存中的该变量在使用前，需要先从主内存加载；而修改后，立即写回到主内存中。但是，尽管如此，也不能保证多线程修改的安全性。
  
#### 禁止指令重排序
volatile修饰的变量在使用或者修改时，造成了内存屏障的效果。
> volatile的开销比锁低

#### 规则描述
volatile修饰变量遵循以下原则：
1. use与load需要按顺序连续一起出现（每次使用前从主内存刷新值）；
2. assign与store需要连续一起出现（修改后，必须同步回内存）；
3. 禁止指令优化，保证代码顺序与程序顺序相同。

# 扩展知识
## 指令重排
- 编译器优化的重排，编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
- 指令并行的重排，现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性(即后一个执行的语句无需依赖前面执行的语句的结果)，处理器可以改变语句对应的机器指令的执行顺序
- 内存系统的重排，由于处理器使用缓存和读写缓存冲区，这使得加载(load)和存储(store)操作看上去可能是在乱序执行，因为三级缓存的存在，导致内存与缓存的数据同步存在时间差。

## 内存屏障
内存屏障（Memory Barrier or Memory Fence），内存屏障，又称内存栅栏，是一个CPU指令，它的作用有两个，一是保证特定操作的执行顺序，二是保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）。
- 由于编译器和处理器都能执行指令重排优化。如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。
- Memory Barrier的另外一个作用是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。


# Reference
- [全面理解Java内存模型(JMM)及volatile关键字](https://blog.csdn.net/javazejian/article/details/72772461)


