# 垃圾收集器
学习垃圾收集器，首先考虑两个关键，垃圾和收集。垃圾，何谓垃圾？如何定位垃圾？收集，如何去收集，收集的思路和具体的实现是什么？

垃圾，所谓垃圾，指的是已经不被程序占用的内存，在Java中，通过引用来使用内存，那么简单来说，垃圾就是没有被引用的内存。（程序计数器、虚拟机栈和本地方法栈随着线程创建和销毁，所以垃圾收集一般针对堆和native内存）

## 如何判定垃圾需要回收？
对象标记的方法分类：

- 简单的方法：引用计数法，计数器记录当前引用的数量，计数器为0，对象不可用（互相引用，出现问题）。
- 可达性分析，以GC Root作为根，判断通过GC Root是否可以到达对象。一般可作为GC Root的对象（why?）：
    1. 虚拟机栈（栈帧中的本地变量表）中引用的对象；
    2. 方法去中类静态属性引用的对象；
    3. 方法区中常量引用的对象；
    4. 本地方法栈中JNI（Native方法）引用对象。
    
> 所谓“GC roots”，或者说tracing GC的“根集合”，就是一组必须活跃的引用。GC roots这组引用是tracing GC的起点。要实现语义正确的tracing GC，就必须要能完整枚举出所有的GC roots，否则就可能会漏扫描应该存活的对象，导致GC错误回收了这些被漏扫的活对象。

两次标记算法：	
1. 如果检测到对象无连接到GC Root的引用链，进行第一次标记，检测finalize()方法，如果没有覆盖或已经执行了，则直接回收；
2. 如果需要执行finalize()，则放置到F-Queue队列中，由JVM自动建立低优先级的Finalizer线程执行（不保证finalize执行完成）。针对F-Queue队列进行第二次标记，如果finalize()中对象被链接，则移出队列，否则将其回收。（对于任何对象的finalize只会被调用一次）

> 不建议使用finalize()方法，如果finalize()方法效率过低，则影响垃圾回收效率。


### 引用分类
JDK1.2以后提供的引用方式从强到弱：强引用/软引用（内存溢出之前，进行二次回收的对象）/弱引用（存活到下一次垃圾收集发生之前）/虚引用（被回收时，发出一个系统通知）


### 方法区的回收
方法区回收：
1. 废弃常量（无任何实例引用）；
2. 无用的类。
	1. java堆中类的所以实例已经被回收；
	2. 加载该类的ClassLoader被回收；
	3. 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载功能。

## 垃圾收集思路？
垃圾收集的算法。

1. “标记-清除”算法<br>
    首先标记需要清除对象，在标记完成后统一清除。
    缺点：1. 效率低；2. 空间不连续，产生内存碎片，无法分配大对象。
2. 复制算法<br>
划分为左右两个部分，先使用其中一部分（移动堆顶指针），这一部分用完，将存活对象复制到另外一部分，再继续分配，清空原先的部分。（改进：比例不用1：1，可以划分为一块较大的内存Eden和一块较小的内存Survivor，回收时将存活对象复制到小内存中，并需要一部分内存（老年代）作为担保）
    - 优点：高效垃圾收集，无碎片产生；
    - 缺点：缩小一半内存（存活率较高情况下，复制代价高）。
3. 标记-整理算法<br>
针对老年代存活率较高的情境下，使用标记对象，然后将存活对象向一端移动，清除端边界以外的内存。
4. 分代收集算法<br>
新生代使用复制算法，进行少量对象复制成本，快速清理垃圾（存活率低，需要有担保）；
老年代使用标记整理（清理）算法，清理垃圾（存活率高，无担保）；


## 垃圾收集具体实现（HotSpot）？

### 枚举根节点：
需要通过所有根节点的可达性分析，用以标记可回收对象。可以推断，为了防止引用变化，在枚举根节点时，将所有的线程中断（停顿），如果枚举根节点的时间过长，会严重影响性能。
- 优化，Hotspot通过OopMap的数据结构加速枚举的过程，在类加载完成时，HotSpot会计算并记录对象中不同类型数据位置，GC通过直接扫描可以获取信息。（空间换时间）
- 缺点弥补，如果OopMap针对每个指令都记录，则耗费过多的空间存储，所以，只在“安全点”（safepoint）记录对应信息。而“安全点”的选择则是根据“是否让程序长时间执行的特征”（指令序列的复用，方法跳转、循环跳转等）

#### 多线程的安全点
面对多线程的情况下，如何将线程都跑到安全点，有两种方案可以选择：

1. 抢先式中断，中断所有线程，如果有线程未到安全点，则恢复线程运行到安全点。（很少使用，why? 个人猜测：可能与线程以中断的方式停止工作类似）。
2. 主动式中断，不针对线程操作，设置标志（安全点），由各个线程主动轮询。当需要中断，将内存也设置不可读，线程产生一个自陷异常信号，在异常处理器中暂停线程实现等待。（安全点轮询和出发线程中断）

#### 安全区
当一个线程长时间sleep或blocked状态，需要解决GC问题
安全区域指的是一段代码片段中，引用关系不会发生变化。在这块区域GC是安全的。当进入安全区域，进行标记；离开时，需要GC完成（或枚举过程结束）信号才能离开。

### 垃圾收集器
- 新生代收集器：Serial、ParNew、Parallel Scavenge；
- 老年代收集器：Serial Old、Parallel Old、CMS；
- 整堆收集器：G1；

#### Serial收集器
单线程收集垃圾，暂停其他所有线程。
- 简介<br>
    GC线程（新生代使用复制算法）-> 其他线程 -> GC线程（老年代采用标记-整理算法）
    （新生代较小情况下，单线程收集效率较高，无线程之间交互）
- 使用场景<br>
    单CPU，Client模式，内存较小，停顿短。
- 参数设置<br>
    -XX:+UseSerialGC：添加该参数来显式的使用串行垃圾收集器；

#### ParNew收集器（针对多个CPU）
多线程收集垃圾（控制参数、收集算法、Stop The World、对象分配规则、回收策略等与Serial完全一样），只是采用多条线程收集垃圾。

- 使用场景<br>
在Server模式下（多CPU），ParNew收集器是一个非常重要的收集器，因为除Serial外，目前只有它能与CMS收集器配合工作；但在单个CPU环境中，不会比Serail收集器有更好的效果，因为存在线程交互开销。
- 设置参数<br>
使用-XX:+UseParNewGC强制指定，或者使用-XX:+UseConcMarkSweepGC的默认新生代收集器，使用-XX:ParallelGCThreads控制垃圾收集的线程数。


#### Paralle Scavenge
新生代，复制算法，多线程收集器。与之前区别在于关注可控制的吞吐量，吞吐量 = 运行用户时间 / (运行用户代码时间 + 垃圾收集时间)，此外，提供GC自适应调节策略（GC Ergonomics，-XX:+UseAdaptiveSizePolicy）。配置如下两个优化目标：
- 可以控制最大垃圾收集停顿时间 -XX:MaxGCPauseMills（减少参数，是以频繁垃圾收集为代价）；
- 设置吞吐量大小-XX:GCTimeRatio（0-100, etc.  19 -> (1 / (1 + 19), 5%)，99 -> (1 / (1 + 99), 1%)）

#### Serial Old收集器
Serial收集器的老年代版本，单线程收集器，在Client模式（管理虚拟内存较少）下虚拟机使用。
Server模式下，
- JDK1.5以及之前的版本中，与Parallel Scavenge收集器搭配使用；
- CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。
    
#### Parallel Old收集器
Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。（from JDK 1.6，注重吞吐量和CPU资源敏感场合）

#### CMS收集器
基于“标记-清除”算法，注重最短回收停顿时间，重视服务响应速度。称之为并发低停顿收集器。
- 初始标记，Stop The World，标记直接关联到的对象，单线程。
- 并发标记，GC Root Tracing，与用户线程一起工作。
- 重新标记，修正并发标记期，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录（也会停顿，时间比初始标记稍长，比并发标记短）。
- 并发清除，与用户线程一起工作。<br>
缺点：
- 不利于CPU资源敏感，与用户线程并发执行，导致占用用户资源，当CPU数量不足4个尤为明显。（默认启动回收线程数：CPU数量 + 3 / 4）;
- 无法处理浮动垃圾（Floating Garbage），在标记之后，产生新的垃圾，可能导致“Concurrent Mode Failure”，引起Full GC。此外，在运行中，保留部分内存空间给用户线程使用，（JDK 1.6 92%），当老年代增长过快，导致预留内存不足，出现“Concurrent Mode Failure”，启动后备方案：Serial Old收集器。（预留内存通过-XX:CMSInitiatingOccupancyFraction设置，触发百分比）
- “标记-清除”算法，导致内存碎片过多，无法分配大对象，于是，提供一个碎片整理功能，-XX:+UseCMSCompactAtFullCollection（默认开启），同样，导致回收时间变长。此外，提供一个-XX:CMSFullGCsBeforeCompaction，设置执行多少次不压缩Full GC后，进行一次带压缩的。
    
    
    
#### G1收集器
面向服务端应用的垃圾收集器，关注点也是**降低停顿时间**。

G1收集器划分内存模型方式：将JAVA划分为多个大小相等的区域（Region)，追踪每个Region中垃圾堆积的价值（回收空间大小和回收所需时间的经验值），维护一个优先级列表，每次根据允许的时间值，回收价值最大的Region（在有限时间内，提高效率）。<br>
这里存在一个问题，就是如果不同Region之间存在互相引用，如何Tracing是否对象可清理。如何解决？通过RemeberSet方式，每次对Reference写操作，产生一个Write Barrier暂时中断写操作，检查Reference引用对象是否在不同的Region（或者老年代引用新生代），如果是，则通过CardTable把相关应用信息记录到被应用对象Region的RemeberSet中。（通过遍历RemeberSet，就可以不用全堆扫描）    
    
- 初始标记(Initial Marking) <br>
标记直接关联对象，修改TAMS(Next Top at Mark Start)的值，让下一阶段直接在Region中执行，此阶段需要Stop The World。
- 并发标记(Concurrnet Marking)<br>
从GC Root开始进行可达性分析，找出存活对象，耗时长，可与用户线程并发执行。
- 最终标记(Final Marking)<br>
修正在并发标记期间因用户程序继续运作而产生变化的标记记录，将这段时间的对象变化记录在Remebered Set Logs，然后将Remebered Set Logs的数据合并到Remebered Set中。此阶段停顿线程（也可并发执行）。
- 筛选回收(Live Data Counting and Evacuation)<br>
对各个Region回收价值和成本进行排序，根据用户期望的停顿时间执行回收计划。需要停顿，也可并发执行，但是只回收一部分Region，时间是可控的，停顿大幅提高效率。

特点：
- 并行与并发，并行可以充分利用多个CPU优势，采用多线程标记，缩短Stop the World时间；并发可以让Java用户线程同时进行；
- 分代收集，采用不同方式处理新对象和老对象；
- 空间整合，从整体看是“标记-整理”的算法，从局部（两个Region之间）基于“复制”的算法，
- 可预测停顿*，G1跟踪各个Region里面的垃圾堆积价值大小（回收空间大小/所需时间的经验值），后台维护一个优先级列表，每次根据允许时间，优先回收价值最大的Region。



# Reference
- [垃圾收集器](https://blog.csdn.net/tjiyu/article/details/53983650)